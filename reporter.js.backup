// Load module dependencies
var fs = require ('fs');
var exec = require ('child_process').exec;
var spawn = require ('child_process').spawn;
var gm = require ('gm');
var im = require ('imagemagick');
var zip = require ('node-native-zip');

var id, format, svg, table;

Reporter = function (id, format, svg, table) {

	this.id = id;
	this.format = format;
	this.svg = svg;
	this.table = table;
}

Reporter.prototype.generateReport = function (returnReport) {

	console.log ('this.id = ' + this.id);
	console.log ('this.format = ' + this.format);

	// Step 0: Delete any leftover temporary files
	this.deleteTempFiles (function cbCreateSvg () {

		// If sucessful, create the SVG file
		this.createSvg (returnReport);
	});
}

// Step 0: Delete any leftover temporary files
Reporter.prototype.deleteTempFiles = function (cbCreateSvg) {

	console.log ('format = ' + this.format);	
	console.log ('id = ' + this.id);
	var command = 'rm report*.svg*; '
		+ 'rm ' + settings.tempPath + '*; '
		+ 'rm ' + settings.templateImagePath + '*; '
		+ 'rm ' + settings.reportPath + 'report*.*;';

	exec (command);
	cbCreateSvg ();
}

/*
function deleteTempFiles (tempFiles, index, callback) {
	deleteIfExists (tempFiles[index], function () {
		if (++index === tempFiles.length) {
			callback ();
			return;
		}
		deleteTempFiles (tempFiles, index, callback);
	});
}
*/

// Step 1: Create the SVG File
Reporter.prototype.createSvg = function (returnReport) {

	var svgPath = 'report' + this.id + '.svg';
	console.log ('svgPath = ' + svgPath);

	fs.writeFile (svgPath, this.svg, function cbCreateHtml (err) {
		if (err) throw err;

		console.log ('svg is created');

		// If successful, create the XHTML file
		if (exists (svgPath)) {
			console.log (svgPath + ' exists');
			this.createHtml (svgPath, returnReport);
		}
		else {
			console.log (svgPath + ' does not exist');
		}
	});
}

// Step 2: Create the XHTML file
Reporter.prototype.createHtml = function (svgPath, returnReport) {

	var htmlPath = settings.tempPath + 'report' + this.id + '.html';
	console.log ('htmlPath = ' + htmlPath);

	/* READ THE HTML TEMPLATE settings.htmlTemplatePath */

	var html =
			'<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'
		+ '<html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" lang="en">'
		+ '<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />'
		+ '<title>Rendering amCharts in HTML and PDF</title>'
		+ '<link rel="stylesheet" href="../stylesheets/pdfstyle.css" /></head>'
		+ '<body><div id="report">'
		+ '<h3>Projected Income</h3>'
		+ '<div id="chartDiv">'
		+ '<object data="' + svgPath + '" type="image/svg+xml" width="620px" height="420px"></object>'
		+ '</div>'
		+ this.table
		+ '</div></body></html>';

	fs.writeFile (htmlPath, html, function cbCreateReport (err) {
		if (err) throw err;

		console.log (this.format);

		// If successful, create the PDF or DOCX
		if (exists (htmlPath)) {
			if (this.format == "pdf") this.createPdf (htmlPath, returnReport);
			else if (this.format == "docx") this.createDoc (svgPath, returnReport);
		}
		else {
			console.log (htmlPath + ' was not created');
		}
	});
}

// Step 3: Create the PDF
Reporter.prototype.createPdf = function (htmlPath, returnReport) {

	var reportPath = settings.reportPath + 'report' + this.id + '.pdf';

	// Convert the XHTML to PDF using wkhtmltopdf
	var command =	settings.wkhtmltopdf + " " + htmlPath + " "	+ reportPath;
	exec (command, function cbReturnReport (err) {
		if (err) throw err;

		// If successful, return the report
		if (exists (reportPath)) {
			returnReport ();
		}
		else {
			console.log (reportPath + ' was not created');
		}
	});
}

// Step 3: Create the DOCX
Reporter.prototype.createDoc = function (svgPath, returnReport) {

	var bmpPath = settings.tempPath + 'image' + this.id + '.bmp';

	if (exists (svgPath)) {
		console.log (svgPath + ' exists (createDoc)');
	} else {
		console.log (svgPath + ' does not exist (createDoc)');
	}
	if (exists (bmpPath)) {
		console.log (bmpPath + ' exists (createDoc)');
	} else {
		console.log (bmpPath + ' does not exist (createDoc)');
	}

	// Convert the SVG to BMP
	var command = 'convert -size 600x400 ' + svgPath + ' ' + bmpPath;
	exec (command, function cbReadDocTemplate (err) {
		if (err) throw err;

		// If successful, load the DOCX template
		if (exists (bmpPath)) {
			this.readDocTemplate (bmpPath, returnReport);
		}
		else {
			console.log (bmpPath + ' was not created');
		}
	});
}

// Step 4: Read the document template
Reporter.prototype.readDocTemplate = function (bmpPath, returnReport) {

	var data;
	fs.readFile (settings.docXmlTemplatePath, function cbUpdateDocTable (err, data) {
		if (err) throw err;

		// If successful, insert the table data into
		this.updateDocTable (data, bmpPath, returnReport);
	});
}

// Update the document table	
Reporter.prototype.updateDocTable = function (data, bmpPath, returnReport) {

	var updatedData = data.toString ().replace ("[TABLEDATA]", ""); //table);
	fs.writeFile (settings.docTemplatePath + 'word/document.xml', data, function cbConvertBmpPng () {

		this.convertBmpPng (bmpPath, returnReport)
	});
}

// Convert bmp to png
Reporter.prototype.convertBmpPng = function (bmpPath, returnReport) {

	var pngPath = settings.templateImagePath;
	var command = 'mv ' + bmpPath + '	' + pngPath;
	exec (command, function cbZipDoc (err) {
		if (err) throw err;

		// If successful, zip the DOCX file
		this.zipDoc (returnReport);
	});
}

// Zip the document directory as a docx file
Reporter.prototype.zipDoc = function (returnReport) {

	var reportPath = settings.reportPath + 'report' + this.id + '.docx';
	var archive = new zip ();
	archive.addFiles ([
		{ name: '[Content_Types].xml', path: settings.docTemplatePath + '[Content_Types].xml' },
		{ name: '_rels/.rels', path: settings.docTemplatePath + '_rels/.rels' },
		{ name: 'docProps/app.xml', path: settings.docTemplatePath + 'docProps/app.xml' },
		{ name: 'docProps/core.xml', path: settings.docTemplatePath + 'docProps/core.xml' },
		{ name: 'word/document.xml', path: settings.docTemplatePath + 'word/document.xml' },
		{ name: 'word/fontTable.xml', path: settings.docTemplatePath + 'word/fontTable.xml' },
		{ name: 'word/settings.xml', path: settings.docTemplatePath + 'word/settings.xml' },
		{ name: 'word/styles.xml', path: settings.docTemplatePath + 'word/styles.xml' },
		{ name: 'word/stylesWithEffects.xml', path: settings.docTemplatePath + 'word/stylesWithEffects.xml' },
		{ name: 'word/webSettings.xml', path: settings.docTemplatePath + 'word/webSettings.xml' },
		{ name: 'word/_rels/document.xml.rels', path: settings.docTemplatePath + 'word/_rels/document.xml.rels' },
		{ name: 'word/media/image1.png', path: settings.templateImagePath },
		{ name: 'word/theme/theme1.xml', path: settings.docTemplatePath + 'word/theme/theme1.xml' }
	], function cbWriteZip (err) {
			if (err) throw err;

			// If successful, write the zip file
			this.writeZip (archive, reportPath, returnReport);
	});
}
	
// Write the zipped docx
Reporter.prototype.writeZip = function (archive, reportPath, returnReport) {

	var buff = archive.toBuffer ();
	fs.writeFile (reportPath, buff, function cbReturnReport (err) {
		if (err) throw err;

		// If successful, return the report
		returnReport ();
	});
}

/*
function deleteIfExists (file, callback) {
	var command;
	console.log ('deleting ' + file);
	if (exists (file)) {
		command = 'rm ' + file + '; ';
		exec (command, function report (err) {
			if (err) {
				console.log ('could not delete ' + file);
				throw err;
			} else {
				console.log (file + ' deleted');
			}
			callback ();
		});
	}
	else {
		console.log (file + ' does not exist');
		callback ();
	}
}
*/

Reporter.prototype.exists = function (file) {
	try {
		if (fs.lstatSync (file).isFile ()) return true;
	}
 	catch (err) {
		return false;
	}
}

exports.Reporter = Reporter;
